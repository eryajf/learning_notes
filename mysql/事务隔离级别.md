#### 锁

[参考:MySQL-锁研究](https://blog.csdn.net/puhaiyang/article/details/72284702)

[参考:MySQL-锁深入](https://blog.csdn.net/bigtree_3721/article/details/77417518)


##### 乐观锁

```  
乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好

通常实现:给表加版本号，更新的时候查看刚才取出的版本号是否有变化，如果有，数据回滚，没有，提交

```


##### 悲观锁

悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作

*mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。*

###### 共享锁(lock in share mode)

select操作加，其他select可以访问，update，insert，delete无法访问

```  
终端1:
start transaction; #开启事务
select * from user limit 1 lock in share mode; #加共享锁
终端2:
update user set username="hh" where id = 1; #执行更新同一条数据
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction #返回超时错误
update user set username="hh" where id = 2; #因为终端1中的条件使用了主键索引，没锁全表，终端2可以更新别的行

```

###### 排它锁(for update)

```  
终端1:
start transaction; #开启事务
select * from user limit 1 lock in share mode; #加共享锁
终端2:
update user set username="hh" where id = 1; #执行更新同一条数据
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction #返回超时错误
update user set username="hh" where id = 2; #因为终端1中的条件使用了主键索引，没锁全表，终端2可以更新别的行

```

###### 共享锁和排它锁区别

```  
共同点:都属于悲观锁
区别:
共享锁：事务1加锁后，事务2也可以加锁，事务1执行update操作，由于事务2也加锁了，所以事务1等待，如果事务2也执行update，会出现死锁退出，然后事务1执行成功。
排它锁:事务1加锁后，事务2可以查询，如果事务2也加锁，则会等待，直到事务1释放锁，因为排它锁同一时刻只能有一个加锁成功

```
> 注意：在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁







#### 死锁

```  
死锁的发生与否，并不在于事务中有多少条SQL语句，死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因

```

```  
MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的

```



#### 事务的并发问题

[参考:MySQL-事务隔离级别设置](http://www.cnblogs.com/JohnABC/p/3521061.html)

##### 脏读

**一个事务读到另一个事务，尚未提交的修改，就是脏读**，这里所谓的修改，除了Update操作,不要忘了,还包括Insert和Delete操作。脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。

##### 不可重复读

**在同一个事务中，再次读取数据时【就是你的select操作】，所读取的数据，和第1次读取的数据，不一样了。就是不可重复读**
你的查询结果，将是不确定的。一个不确定的结果，你能容忍吗？

##### 幻读

##### 更新丢失

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题








